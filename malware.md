# Write-up for 2nd Malware Challenge

in this challenge you need first to examine the executable using CFF Explorer, 

![image](https://user-images.githubusercontent.com/8508996/153967012-473c5b00-d7b3-4e35-af76-a6a6799c03e3.png)

as shown the binary is a portable executable in 64 bit, so we throw it on x64dbg to debug it, the steps are quite easy to reach an interesting string on the debugger:
> step 1: open the sample.exe on the x64dbg
>
> step 2: click F9 twice
>
> step 3: you will notice a message box pop-up mentiong the word "Hacking the system ..."

![image](https://user-images.githubusercontent.com/8508996/153967678-738123cf-2721-4c2c-be2d-60e67fcfb102.png)

seeing the powershell string is enough for me to guess there's an execution of powershell command which is typical on common Windows malware, so I immediately go to event viewer to see if an interesting powershell command has been executed, 

go to -> event viewer -> Applications and Services Logs -> Windows PowerShell and filter on 800 Event ID as the following:
![image](https://user-images.githubusercontent.com/8508996/153968004-1b5f24dd-460c-47e3-b81a-abd9d7baeb25.png)
![image](https://user-images.githubusercontent.com/8508996/153968601-cf0250ee-2445-4628-816d-c65a05d45678.png)


and as we gussed, there's a powershell execution with an obfuscated code , so let the manual static reverse engineering journey begins!

`
powershell.exe -c Invoke-Command -ScriptBlock {( new-oBJeCT Io.cOMprESSiON.DeFLaTEstREaM( [iO.mEmORYStrEAm][COnVErt]::FromBasE64sTrIng('nVVbU+JKEH6niv/QJ6VOUpKUoFzE4gHYKCgIB/BSh0ppCANEQ4ZNRiCH5b9vTy4Sa8/uw7Fw0tPT/fXXPT0zACeytDvb7wr7XX4vqTPikxwZ6UscKVfbRAFZWtelU8lr1ycdWvVQ3K7OcSz3JAVAhjEP+roRoSAEqNfE5+ju2e4NUZQr0GQyfCTCNrFRZ0DMbgWNSn0RAUAChRDX7r2pRrGQu8Df2KJ9v9trVh/v9SM0OfmhXJwbA7NljXPkiV0SvWk6K92z1MtErZRLkXRazOdjqVyOBIzx6QBQOrh8WlYqsXCZqOSUx0UhnwQv3LYIbdZxZaAWLhPtit6RdAiFKC6z7I/nDeToKuCR4HA7koIpm6Agb9hiWK0aW9Ygp4TOTd+nXc3fsKlrP2lLoeN+MBwbU5utx5ns1T6TxeQ1TYMl5bjsBz7QBYe5a79bZgvXoAYxOOBfJosrrmc+YRCEX7Yx0i9hohjomDAOHXdAfUcwgENQBOMem5iYimsvLHMJvo3RMfQCGAfqTEz34T9IuMzm5tJjM7f9WyIY6g9clKbfrXWn+qX+rrN/zv/+bpUbs2fz4XzwvGkUZv9um50ZIvQrhXlnjsIa/2/bvVnn7GZwir7wnapgopKLYfpCRfVhZmeyimOu59R72QoNJujx4UWJ+maDjZAr9+jaZc0UMZObkXsmuwdEFuA1SIEAshWFO2j+iiIF9B3VwkJgfDzjZAMDMT/5iiCQ92CUigU4BsVooWo8FHanYLTjiXCWE8Fj24n6IiyuEgNUi0ZLOdcgNcnh+icWupWKqAjDJQv4TYK2wmKhohaKwjo0zeNaO1yrhV/M/BjwfMC30ApTeIn4xTGN2zQZsUMHPsL0QCZKfMHnLu1od0J5DKHBXVyGl1RNbmMKtyEFhIVjMQgixWJBQ1k7gysh4rcGUQx/7tWjLFF1F0u5b1EWYaqDcCcU3DXcFxHCpzxocHqjVa5HD9gb87Bpp8xydY1v6ShpkggzoPh9jzAc0XTr38NMcZlZOCCS6NEUWNxxh36DqOESWmETYcd90gybDbVfzaPuSrozmcSNiSacehYdoqAp9ANPOfZ84HCXOvYQxOm16gjpMc/TVUibA12a96ooGE5WHmvqeBPqg/rT6Lo3RLHa7dy1hN2Cm30VAjxPK+b1Mbm2ijWIu+qTfMhlbjrXMRNRkl/IiApZ9QOZ2D6m8j95pEqUyYYX3kpEZ94NhHDRrZbc4Jnsew+3zmWcfzT+eKfGlz86eGyDDL3r8DLEbHzq9fEiRfAvGpFF4EyW1PfrqnAfqdNpnciypFydyHC001/v11XrlXX9ld7cjy9y+WKuUDTUt57tEqLgUyee1C8PO+DL/mjig+tQHAZ2fSLeXTLYrjDF83IPZ4r2aDoftFqV3tir7UoyweNwtKsvXyul/n6s5jVNBRkVXVSs9prUoa/3N7yFT7ehKPAT'),[io.CoMPRessIoN.coMpREssiOnmOdE]::dEcOMpReSs)| % {new-oBJeCT syStEm.iO.STreamrEAdeR($_,[tEXT.eNCoDING]::aSCii) }).rEadtoeNd()| & ((Gv '*Mdr*').naMe[3,11,2]-JOiN'')}
`

to read the obfuscated code we need first to understand what it actually do, the powershell Invoke-Command will execute an inline powershell code using scriptblock option and within this script block it will decode (base64) and decompress(deflate) the code, then, try to pass the plain-text code to a readstream and finally execute it 
```
& ((Gv '*Mdr*').naMe[3,11,2]-JOiN'')
```
if we take this weird powershell one-liner script and execute it by its own in a powershell cmd prompt,

![image](https://user-images.githubusercontent.com/8508996/153969862-9f06e703-bdc9-4669-870c-8ad53d9b8b4c.png)

it will be evaluated to "iex" string which mapped to invoke-expression that will execute the entire scriptblock which is quite risky, if this is a real malware and not a safe CTF challenge you will infect your system! so be careful dealing with obfuscated powershell script and never run it on your personal/work machine, instead use an isolated environment for that purpose ;)

so what we can do now and how to read this encoded/compressed powershell? 

the answer is very simple, you just need to replace:
```
& ((Gv '*Mdr*').naMe[3,11,2]-JOiN'')
```
with:
```
write-output
```

and the full encoded/compressed code will appear but still its obfuscated which require additional work to see the entire picture

![image](https://user-images.githubusercontent.com/8508996/153970368-1761d0f5-7f47-4fa5-a7db-0f31b217f0f3.png)


#### full text:
```
  &("{0}{2}{1}"-f's','TEm','et-I') ("vA"+"rIAbLe:r"+"xp3"+"7O")  ( [tyPE]("{0}{1}" -F'st','rinG')); .('SV')  ("{0}{1}"-f 'aM8','6P') (  " )''niOj-]52,42,4[cePsMOC:VNE$ ( &|)43]RaHc[,'Wo9'ECalpErc-93]RaHc[,)76]RaHc[+511]RaHc[+77]RaHc[(  ECalpErc-  63]RaHc[,)711]RaHc[+88]RaHc[+911]RaHc[(ECalpErc-  421]RaHc[,'2JH'eCAlpER-29]RaHc[,'peK' ECalpErc-  )')nociuXw ,epytuXw ,eltituXw ,ydobuXw(wohS::]xoB'+'egasseM.swodniW.m'+'etsyS[]diov[
;}
Wo9... met'+'sys eht gnikcaHWo9 = ydobuXw
gninraW::]egamIxoBegasseM.swodniW.metsyS[ = nociuXw
{ esl'+'e }
Wo9... gnitroba ,enihcam siht kcah ot elbanUWo9 = ydobuXw
noitamrofnI::]egamIxoBegasseM.swodni'+'W.metsyS[ = nociuXw
{ )CsM=MdE9EkEoZ3Qqc7BfXaU3RXwB2fzxCLf'+'P82gLg'+'v'+'JIOfL0GR+CsM qe- a'+'ta'+'d_euXw( fi
)lavger_xuXw(gnirtS46esaBoT::]trevnoC.metsyS[ = atad_euXw
} CsMCsM = lavger_xuXw { )l'+'avger_xuXw!( fi
yek'+'uXw ataduX'+'w RuXw & = lavger_xuXw
} } ]652 % )]HuXw[SuXw + ]IuXw[SuX'+'w([SuX'+'wroxb-_uXw ;]IuXw[Su'+'Xw ,]HuXw[SuXw = ]HuXw[SuXw ,'+']IuXw[SuXw ;65'+'2 % )'+']IuXw'+'[SuXw + HuXw( '+'= HuXw ;652 % )1 + IuXw( = IuXw { % 2JH DuXw ;} ]_uX'+'w[SuXw ,]JuXw[SuXw = ]'+'JuXw[SuXw ,]_uXw[SuXw ;652 % )]htgneL.KuXw % _uXw[KuXw + ]_uXw[SuXw + JuXw( = JuXw {'+' %'+' 2JH 552.'+'.0 ;552..0 = SuXw ;sgrAuXw'+' = KuXw'+' ,DuXw { '+'= RuXw
)yekgeruXw(setyBteG.8FTU::]gni'+'docnE.txeT.metsyS['+' = ye'+'kuXw
)la'+'vgeruXw(setyBteG.8FTU::]gnid'+'oc'+'nE.'+'txeT.metsyS[ = ataduXw
} CsM CsM = yekgeruX'+'w { )yekgeruXw!( fi'+'
} CsM CsM = lavgeruXw { )lavgeruXw!( fi
CsMterceSCsM.)eunitnoCyltneliS noitcA'+'rorrE- CsMterceSCsM emaN- '+'CsMproCEpeKERAWTFOSpeK:MLKHCsM htaP- ytreporPmetI-teG( '+'= yekgeruXw
CsMgalFCsM.)eu'+'nitnoCyltneliS noi'+'tcArorrE- CsMgalFCsM emaN- CsMproCEpeKERAWTFOSpeK:MLKHCsM htaP- ytreporPmetI-teG( = lavgeruXw

Wo9pu'+'orG proCEWo9 = eltituXw
kO::]nottuBxoBegasseM.swodniW.metsyS[ = epytuXw
krowemarFnoitatneserP ,eroCnoitatneserP emaNylbmessA- epyT-ddA'((");&( ${E`Nv:c`oMspEC}[4,15,25]-jOin'')(   (  &("{0}{2}{1}" -f'Va','le','RiAb') ('Rxp'+'37O') ).Value::"jo`in"('' ,${Am`86P}[-1..- (${AM`86p}."Le`NGtH" )]))
```
the most interested part on the first line is this:

`
.('SV')  ("{0}{1}"-f 'aM8','6P') (  " )
`

which will set a variable name **aM86P** starting from the double quote " to the second appeared double quote " on this line:

`
krowemarFnoitatneserP ,eroCnoitatneserP emaNylbmessA- epyT-ddA'((")
`

by stuyding the script it seems most of the part are in a reverse order, but powershell couldn't execute a reversed powershell so there must be a way in the code to reverse then execute the code, and here's exactly the line which resopnsible to reverse the code and execute it using our old mentioned technique using "iex" keyword

``
"jo`in"('' ,${Am`86P}[-1..- (${AM`86p}."Le`NGtH" )])
``

So we know it creates a variable name **Am86P** let's inspect this using the command line,

![image](https://user-images.githubusercontent.com/8508996/153971713-aa48473f-bf44-4d3e-9b25-55d2ecb951c3.png)

now all what we need to do is to reverse and print the final code using this powershell command:
```
PS C:\Users\User> -join ${Am`86P}[-1..- (${AM`86p}."Le`NGtH" )]
```
the output is this:

![image](https://user-images.githubusercontent.com/8508996/153971996-d32278b7-4443-4366-97c8-11002e099fff.png)

we thought we are done deobfuscating the powershell script, but still there's another level of obfuscation, I don't think this will be tough after doing all previous steps with the write-output trick which do wonder :P 

so we replace the last code with write-output hit [ENTER] 

![image](https://user-images.githubusercontent.com/8508996/153972445-cc2bf37a-5280-44c3-a0ff-6f6979727587.png)


Bingo! we got the final code :)

```
Add-Type -AssemblyName PresentationCore, PresentationFramework
$type = [System.Windows.MessageBoxButton]::Ok
$title = "ECorp Group"

$regval = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\ECorp' -Name 'Flag' -ErrorAction SilentlyContinue).'Flag'
$regkey = (Get-ItemProperty -Path 'HKLM:\SOFTWARE\ECorp' -Name 'Secret' -ErrorAction SilentlyContinue).'Secret'
if (!$regval) { $regval = ' ' }
if (!$regkey) { $regkey = ' ' }
$data = [System.Text.Encoding]::UTF8.GetBytes($regval)
$key = [System.Text.Encoding]::UTF8.GetBytes($regkey)
$R = { $D, $K = $Args; $S = 0..255; 0..255 | % { $J = ($J + $S[$_] + $K[$_ % $K.Length]) % 256; $S[$_], $S[$J] = $S[$J], $S[$_] }; $D | % { $I = ($I + 1) % 256; $H = ($H + $S[$I]) % 256; $S[$I], $S[$H] = $S[$H], $S[$I]; $_-bxor$S[($S[$I] + $S[$H]) % 256] } }
$x_regval = & $R $data $key
if (!$x_regval) { $x_regval = '' }
$e_data = [System.Convert]::ToBase64String($x_regval)
if ($e_data -eq '+RG0LfOIJvgLg28PfLCxzf2BwXR3UaXfB7cqQ3ZoEkE9EdM=') {
$icon = [System.Windows.MessageBoxImage]::Information
$body = "Unable to hack this machine, aborting ..."
} else {
$icon = [System.Windows.MessageBoxImage]::Warning
$body = "Hacking the system ..."
};
[void][System.Windows.MessageBox]::Show($body, $title, $type, $icon)
```
clearly, the code now are more readable and we have a full knowledge on what the code are doing, which is pulling the flag value and a secret/key under the ECorp registry key, then pass it to $R function which mimic the RC4 encryption.

### Resources
- https://inquest.net/blog/2019/03/10/analyzing-sophisticated-powershell-targeting-japan
- https://malware.news/t/deobfuscating-powershell-putting-the-toothpaste-back-in-the-tube/23509
- https://www.zscaler.com/blogs/security-research/independence-day-greeting-campaign-delivers-emotet-5
- https://gist.github.com/HarmJ0y/4edc5bf4cccb0aef5553a860a3e433e3
